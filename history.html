<!DOCTYPE html>
<html>
<!-- A usable HTML template for input-history overlay using Browser Source and Websocket -->

<!-- By: https://github.com/christiankyle-ching/ -->

<head>
  <meta charset='utf-8' />
  <title>input-history Windows</title>
  <style>
    html {
      height: 100%;
      position: relative;
      caret-color: transparent
    }

    body {
      font-family: Arial, Helvetica, sans-serif;
      font-size: 24px;
      color: #fff;
      overflow: hidden
    }

    .bottom-align {
      bottom: 0px;
    }

    .player1 {
      float: left;
    }

    .player2 {
      float: right;
    }

    .mainHolder {
      left: 5px;
      top: 10px;
      width: 237px;
      position: relative;
    }

    .histHolder {
      height: 900px;
    }

    .centerHolder {
      bottom: 100px;
      position: fixed;
      margin: 0 auto;
      transform: scale(0.32, 0.32);
    }

    div#history {
      list-style-type: none
    }

    p.key-combination.hidden {
      opacity: 0;
      transition-property: opacity;
      transition-timing-function: ease-out;
      transition-duration: 1s
    }

    *+p.key-combination {
      margin-top: 0;
      line-height: 1.7em
    }

    p.key-combination>* {
      vertical-align: middle
    }

    p.key-combination>.separator {
      display: inline-block;
      margin-left: 0;
      margin-right: 0
    }

    span.key {
      background-color: #3F3F3F;
      display: inline-flex;
      padding: .2em;
      line-height: 1em;
      white-space: nowrap;
      height: 1em;
      font-weight: 700;
      filter: drop-shadow(.4rem .4rem 1rem #DDD);
      justify-content: center;
      align-items: center;
      border-radius: 50%;
      width: 1em
    }

    span.repeat {
      display: inline-flex;
      padding: .1em;
      line-height: 1em;
      white-space: nowrap;
      height: 1em;
      font-weight: 700;
      filter: drop-shadow(.4rem .4rem 1rem #DDD);
      justify-content: end;
      align-items: end;
      width: 1.7em;
      border-radius: .6em;
      text-shadow: 2px 2px 0 #000, -2px -2px 0 #000, -2px 2px 0 #000, 2px -2px 0 #000, 0 2px 0 #000, 0-1px 0 #000, -2px 0 0 #000, 2px 0 0 #000
    }

    .icon-sm {
      width: 1em;
      height: 1em;
      display: block;
      margin: auto
    }

    span.key div {
      display: inline-flex;
      white-space: nowrap
    }

    *+.icon-sm,
    .icon-sm+* {
      margin-left: 0
    }

    ul,
    li {
      list-style: none;
      float: left
    }

    .arrowHolder .x,
    .arrowHolder .y {
      margin: 0 1px;
      position: absolute;
      left: 0;
      top: 15px
    }

    .arrow-right,
    .arrow-left,
    .arrow-up,
    .arrow-down {
      width: 0;
      height: 0;
      display: inline-block;
      position: absolute
    }

    .arrow-right {
      border-top: 5px solid transparent;
      border-bottom: 5px solid transparent;
      border-left: 5px solid #D02F53;
      left: 8px;
      top: 7px
    }

    .arrow-left {
      border-top: 5px solid transparent;
      border-bottom: 5px solid transparent;
      border-right: 5px solid #D02F53;
      left: 1px;
      top: 7px
    }

    .arrow-up {
      border-left: 5px solid transparent;
      border-right: 5px solid transparent;
      border-bottom: 5px solid #D02F53;
      left: 2px;
      top: 20px
    }

    .arrow-down {
      border-left: 5px solid transparent;
      border-right: 5px solid transparent;
      border-top: 5px solid #D02F53;
      left: 2px;
      top: 27px
    }

    .stickType li>.arrow-down {
      top: 46px;
      left: 60px;
      display: none
    }

    .stickart {
      position: relative
    }

    .container {
      position: absolute
    }

    .stick.container {
      height: 150px;
      width: 150px
    }

    .washer,
    .canvas {
      height: 250px;
      width: 250px;
      position: absolute;
      top: 50%;
      left: 50%;
      margin: -125px;
    }

    .washer,
    .canvas {
      filter: drop-shadow(.4rem .4rem 1rem #DDD);
      border-radius: 75px
    }

    .ballTop {
      border-radius: 50px;
      background-color: #fdfdfd;
      background-image: -webkit-gradient(linear, 0 0, 0 100%, from(#fdfdfd1a), to(#c0c7c71a));
      background-image: -webkit-linear-gradient(#fdfdfd1a, #c0c7c71a);
      background-image: -moz-linear-gradient(#fdfdfd1a, #c0c7c71a);
      background-image: -o-linear-gradient(#fdfdfd1a, #c0c7c71a);
      background-image: linear-gradient(#fdfdfd1a, #c0c7c71a);
      height: 100px;
      width: 100px;
      left: 25px;
      top: 25px;
      position: absolute
    }

    .ballTop-body {
      border-radius: 50px;
      height: 100px;
      width: 100px;
      top: 50%;
      left: 50%;
      margin: -50px 0 0 -50px;
      position: relative
    }

    .buttons.container {
      height: 220px;
      width: 450px
    }

    .MCZ_SE .buttons.container {
      top: 30px;
      left: 250px
    }

    .MCZ_SE .stick.container {
      top: 64px;
      left: 60px
    }

    .row {
      position: relative;
      display: block;
      margin: 0
    }

    .btm {
      top: 5px;
      left: 3px
    }

    .top {
      left: 25px
    }

    .line .lp {
      top: 80px;
      left: 2px
    }

    .line .mp {
      top: 20px;
      left: -2px
    }

    .line .hp {
      top: 0;
      left: 5px
    }

    .line .ap {
      top: 10px;
      left: 11px
    }

    .box .lp {
      top: -5px;
      left: 0px
    }

    .box .mp {
      top: 105px;
      left: -112px
    }

    .box .hp {
      top: -10px;
      left: -92px
    }

    .box .ap {
      top: 100px;
      left: -202px
    }

    .samurai .lp {
      top: -5px;
      left: 0px
    }

    .samurai .mp {
      top: -10px;
      left: 10px
    }

    .samurai .hp {
      top: 105px;
      left: -212px
    }

    .samurai .ap {
      top: 100px;
      left: -202px
    }


    .box .lp {
      top: -5px;
      left: 0px
    }

    .box .mp {
      top: 105px;
      left: -112px
    }

    .box .hp {
      top: -10px;
      left: -92px
    }

    .box .ap {
      top: 100px;
      left: -202px
    }

    .line .lk,
    .box .lk,
    .samurai .lk {
      display: none
    }

    .line .mk,
    .box .mk,
    .samurai .mk {
      display: none
    }

    .six .lp {
      top: -5px;
      left: 0px
    }

    .six .mp {
      top: -10px;
      left: 10px
    }

    .six .hp {
      top: -5px;
      left: 20px
    }

    .six .ap {
      top: 105px;
      left: -312px
    }

    .six .lk {
      top: -10px;
      left: 102px
    }

    .six .mk {
      top: -5px;
      left: 112px
    }

    .buttonHolder {
      float: left;
      display: block;
      position: relative
    }

    .btn-bdg {
      background-color: transparent;
      height: 100px;
      margin: 1px;
      position: relative;
      width: 100px;
      display: inline-block
    }

    .btn-wrap {
      border-radius: 50px;
      background-color: #fdfdfd;
      background-image: -webkit-gradient(linear, 0 0, 0 100%, from(#fdfdfd1a), to(#c0c7c71a));
      background-image: -webkit-linear-gradient(#fdfdfd1a, #c0c7c71a);
      background-image: -moz-linear-gradient(#fdfdfd1a, #c0c7c71a);
      background-image: -o-linear-gradient(#fdfdfd1a, #c0c7c71a);
      background-image: linear-gradient(#fdfdfd1a, #c0c7c71a);
      filter: drop-shadow(.4rem .4rem 1rem #DDD);
      height: 100px;
      width: 100px;
      left: 50%;
      top: 50%;
      position: absolute;
      margin: -40px 0 0 -40px
    }

    .white {
      background-color: #F4F4F4DF
    }

    .black {
      background-color: #232323DF
    }

    .darkblue {
      background-color: #4F53B7DF
    }

    .charcoal {
      background-color: #4F565CDF
    }

    .orange {
      background-color: #E96906DF
    }

    .btn-body {
      border-radius: 50px;
      display: table;
      height: 100px;
      width: 100px;
      top: 50%;
      left: 50%;
      margin: -50px 0 0 -50px;
      position: relative;
      font-weight: 700;
      font-size: 80px;
      justify-content: center;
      align-items: center;
      text-align: center;
    }

    *,
    div {
      margin: 0;
      padding: 0
    }

    span.bl,
    .darkred {
      background-color: #A40911DF
    }

    span.lp,
    .vermillion {
      background-color: #D70800DF
    }

    span.mp,
    .yellow {
      background-color: #EBBB04DF
    }

    span.hp,
    .green {
      background-color: #1FB426DF
    }

    span.ap,
    .lightblue {
      background-color: #3B9AF5DF
    }

    span.lk,
    .violet {
      background-color: #9F32AFDF
    }

    span.mk,
    .pink {
      background-color: #F17492DF
    }

    #icons-container,
    .hide {
      display: none
    }

    .ballTop-body:inactive,
    .btn-body:inactive {
      background: #0009;
      color: #999999FB
    }

    .ballTop-body.inactive,
    .btn-body.inactive {
      background: #0009;
      color: #999999FB
    }

    .debugBox {
      width: 1100px;
      height: 30%;
      background-color: #404040FD;
      position: absolute;
      top: 15%;
      left: 50%;
      transform: translate(-50%, -50%);
    }

    div.debugBox.hidden {
      opacity: 0;
      transition-property: opacity;
      transition-timing-function: ease-out;
      transition-duration: 1s
    }

    .debugText {
      font-size: larger;
      position: absolute;
      top: 50%;
      left: 50%;
      transform: translate(-50%, -50%);
      width: 100%;
    }

    /* https://stackoverflow.com/questions/4810841/pretty-print-json-using-javascript */
    .jsonString {
      color: green;
    }

    .jsonNumber {
      color: darkorange;
    }

    .jsonBoolean {
      color: blue;
    }

    .jsonNull {
      color: magenta;
    }

    .jsonKey {
      color: red;
    }
  </style>
</head>

<body>
  <!-- #region Icons -->
  <div id='icons-container'>
    <!-- Get Icons from FontAwesome -->
    <!-- Copy SVG Code -->

    <!-- #region Svg sources used multiple times. Automatically hidden -->
    <!-- Arrow Left -->
    <svg xmlns='http://www.w3.org/2000/svg'>
      <symbol id='icon-arrow' viewBox='0 0 375 375'>
        <path
          d='M93.81 112.5C46.69 152.94 8.06 186.5 7.94 187.06 7.81 187.62 46.56 221.44 94.12 262.12 94.12 262.12 180.62 336.06 180.62 336.06 180.62 336.06 180.94 296.81 180.94 296.81 180.94 296.81 181.31 257.5 181.31 257.5 181.31 257.5 272.5 257.5 272.5 257.5 272.5 257.5 363.75 257.5 363.75 257.5 363.75 257.5 363.75 187.5 363.75 187.5 363.75 187.5 363.75 117.5 363.75 117.5 363.75 117.5 272.5 117.5 272.5 117.5 272.5 117.5 181.25 117.5 181.25 117.5 181.25 56.44 180.81 38.81 180.31 38.87Z' />
      </symbol>
    </svg>

    <!-- Arrow Left -->
    <svg id='SVG_VC_LEFT'>
      <use href='#icon-arrow'></use>
    </svg>

    <!-- Arrow Right -->
    <svg id='SVG_VC_RIGHT' style='transform: rotate(180deg);'>
      <use href='#icon-arrow'></use>
    </svg>

    <!-- Arrow Up -->
    <svg id='SVG_VC_UP' style='transform: rotate(90deg);'>
      <use href='#icon-arrow'></use>
    </svg>

    <!-- Arrow Down -->
    <svg id='SVG_VC_DOWN' style='transform: rotate(270deg);'>
      <use href='#icon-arrow'></use>
    </svg>

    <!-- Arrow UP Left -->
    <svg id='SVG_VC_UP_LEFT' style='transform: rotate(45deg);'>
      <use href='#icon-arrow'></use>
    </svg>

    <!-- Arrow UP Right -->
    <svg id='SVG_VC_UP_RIGHT' style='transform: rotate(135deg);'>
      <use href='#icon-arrow'></use>
    </svg>

    <!-- Arrow Down Left -->
    <svg id='SVG_VC_DOWN_LEFT' style='transform: rotate(315deg);'>
      <use href='#icon-arrow'></use>
    </svg>

    <!-- Arrow Down Right -->
    <svg id='SVG_VC_DOWN_RIGHT' style='transform: rotate(225deg);'>
      <use href='#icon-arrow'></use>
    </svg>
  </div>
  <!-- #endregion -->

  <div class='playersHolder'>
    <div class='mainHolder'>
      <div class='histHolder'>
        <div class='history'></div>
      </div>
      <div class='centerHolder'>
        <div class='stickart MCZ_SE line'>
          <div class='stick container'>
            <div class='washer white'></div>
            <canvas class='canvas' height='782' width='782'>
            </canvas>
            <div class='ballTop vermillion'>
              <div class='ballTop-body inactive'>
              </div>
            </div>
          </div>
          <div class='buttons container'>
            <div class='top row'>
              <div class='buttonHolder'>
                <div class='btn-bdg lp'>
                  <div class='btn-wrap vermillion'>
                    <div class='btn-body inactive'>
                      <span class='btn-txt'>A</span>
                    </div>
                  </div>
                </div>
              </div>
              <div class='buttonHolder'>
                <div class='btn-bdg mp'>
                  <div class='btn-wrap yellow'>
                    <div class='btn-body inactive'>
                      <span class='btn-txt'>B</span>
                    </div>
                  </div>
                </div>
              </div>
              <div class='buttonHolder'>
                <div class='btn-bdg hp'>
                  <div class='btn-wrap green'>
                    <div class='btn-body inactive'>
                      <span class='btn-txt'>C</span>
                    </div>
                  </div>
                </div>
              </div>
              <div class='buttonHolder'>
                <div class='btn-bdg ap'>
                  <div class='btn-wrap lightblue'>
                    <div class='btn-body inactive'>
                      <span class='btn-txt'>D</span>
                    </div>
                  </div>
                </div>
              </div>
              <div class='buttonHolder'>
                <div class='btn-bdg lk'>
                  <div class='btn-wrap violet'>
                    <div class='btn-body inactive'>
                      <span class='btn-txt'>E</span>
                    </div>
                  </div>
                </div>
              </div>
              <div class='buttonHolder'>
                <div class='btn-bdg mk'>
                  <div class='btn-wrap pink'>
                    <div class='btn-body inactive'>
                      <span class='btn-txt'>F</span>
                    </div>
                  </div>
                </div>
              </div>
            </div>
          </div>
        </div>
      </div>
    </div>
  </div>

  <div class='debugHolder'>
    <div class='debugBox hidden'>
      <div class='debugText'>
      </div>
    </div>
  </div>
</body>

<script>
  // #region ----- YOU CAN CHANGE THESE VALUES -----

  let HIST_HTML = true;
  let INPUT_HTML = true;
  let DEBUG = false;
  let OPACITY = 100.0 / 100.0;
  let PORT = 16899;
  const FRAME_PERIOD = 1000 / 60;
  let _ws = null;

  /**
   * Max count of history shown. Lower = better performance.
   * @type {number}
   */
  let HISTORY_MAX = 20;
  /**
   * Time delay in ms before the key is hidden.
   * @type {number}
   */
  let HISTORY_TIMEOUT = 30000;
  /**
   * Enable / Disable timeout for key combinations
   * @type {boolean}
   */
  let HISTORY_TIMEOUT_ACTIVE = HISTORY_TIMEOUT > 0;
  /**
   * Align history to top of source when true and add newer keys to top.
   * @type {boolean}
   */
  let HISTORY_TOP_ALIGN = true;
  /**
   * Separator between keys
   * @type {string}
   */
  const SEPARATOR = '';

  // #endregion

  const INPUT_NAN = 0x1000;
  const INPUT_UP = 0x100;
  const INPUT_DOWN = 0x200;
  const INPUT_LEFT = 0x400;
  const INPUT_RIGHT = 0x800;
  const INPUT_UP_AND_DOWN = INPUT_UP | INPUT_DOWN;
  const INPUT_LEFT_AND_RIGHT = INPUT_LEFT | INPUT_RIGHT;
  const INPUT_LP = 0x01;
  const INPUT_MP = 0x02;
  const INPUT_HP = 0x04;
  const INPUT_AP = 0x08;
  const INPUT_LK = 0x10;
  const INPUT_MK = 0x20;
  const INPUT_HK = 0x40;
  const INPUT_AK = 0x80;
  const INPUT_MASK_ARROW = INPUT_UP | INPUT_DOWN | INPUT_LEFT | INPUT_RIGHT;
  const INPUT_MASK_BUTTON = INPUT_LP | INPUT_MP | INPUT_HP | INPUT_AP | INPUT_LK | INPUT_MK | INPUT_HK | INPUT_AK;
  
  const GP2040_K1    = 0x0000;
  const GP2040_K2    = 0x0001;
  const GP2040_P1    = 0x0002;
  const GP2040_P2    = 0x0003;
  const GP2040_S1    = 0x0004;
  const GP2040_R2    = 0x0005;
  const GP2040_S2    = 0x0006;
  const GP2040_L3    = 0x0007;
  const GP2040_R3    = 0x0008;
  const GP2040_L1    = 0x0009;
  const GP2040_R1    = 0x000A;
  const GP2040_UP    = 0x000B;
  const GP2040_DOWN  = 0x000C;
  const GP2040_LEFT  = 0x000D;
  const GP2040_RIGHT = 0x000E;

  /**
   * Keycodes from: https://github.com/kwhat/libuiohook/blob/1.2/include/uiohook.h
   * [0] -> libuiohook key
   * [1] -> optional alias
   *
   * Comment out keys that you don't want to show
   */
  const KEYBIS_MAP = new Map();
  new Map([
    // Arrow Keys
    [[1, 'k1', 'key', 0x0e48], INPUT_UP],    // 1P UP    as ARROW UP
    [[1, 'k1', 'key', 0x0e4b], INPUT_LEFT],  // 1P UP    as ARROW LEFT
    [[1, 'k1', 'key', 0x0e4d], INPUT_RIGHT], // 1P UP    as ARROW RIGHT
    [[1, 'k1', 'key', 0x0e50], INPUT_DOWN],  // 1P UP    as ARROW DOWN
    /* libuihook values */
    [[1, 'k1', 'key', 0xe048], INPUT_UP],    // 1P UP    as ARROW UP
    [[1, 'k1', 'key', 0xe04b], INPUT_LEFT],  // 1P UP    as ARROW LEFT
    [[1, 'k1', 'key', 0xe04d], INPUT_RIGHT], // 1P UP    as ARROW RIGHT
    [[1, 'k1', 'key', 0xe050], INPUT_DOWN],  // 1P UP    as ARROW DOWN
    /* https://github.com/univrsal/input-overlay/issues/174 */
    [[1, 'k1', 'key', 0xee48], INPUT_UP],    // 1P UP    as ARROW UP
    [[1, 'k1', 'key', 0xee4b], INPUT_LEFT],  // 1P UP    as ARROW LEFT
    [[1, 'k1', 'key', 0xee4d], INPUT_RIGHT], // 1P UP    as ARROW RIGHT
    [[1, 'k1', 'key', 0xee50], INPUT_DOWN],  // 1P UP    as ARROW DOWN
    [[1, 'k1', 'key', 0x0010], INPUT_LP],    // 1P A     as KEYBOARD Q
    [[1, 'k1', 'key', 0x0011], INPUT_MP],    // 1P B     as KEYBOARD W
    [[1, 'k1', 'key', 0x0012], INPUT_HP],    // 1P C     as KEYBOARD E
    [[1, 'k1', 'key', 0x001e], INPUT_AP],    // 1P D     as KEYBOARD A
    [[1, 'k1', 'key', 0x001F], INPUT_LK],    // 1P E     as KEYBOARD S
    [[1, 'k1', 'key', 0x0020], INPUT_MK],    // 1P F     as KEYBOARD D
    // Player TWO
    [[2, 'k1', 'key', 0x0016], INPUT_UP],    // 2P UP    as KEYBOARD U
    [[2, 'k1', 'key', 0x0024], INPUT_DOWN],  // 2P DOWN  as KEYBOARD J
    [[2, 'k1', 'key', 0x0023], INPUT_LEFT],  // 2P LEFT  as KEYBOARD K
    [[2, 'k1', 'key', 0x0025], INPUT_RIGHT], // 2P RIGHT as KEYBOARD H
    [[2, 'k1', 'key', 0x0047], INPUT_LP],    // 2P A     as KEYPAD 7 
    [[2, 'k1', 'key', 0x0048], INPUT_MP],    // 2P B     as KEYPAD 8
    [[2, 'k1', 'key', 0x0049], INPUT_HP],    // 2P C     as KEYPAD 9
    [[2, 'k1', 'key', 0x004b], INPUT_AP],    // 2P D     as KEYPAD 4
    [[2, 'k1', 'key', 0x004c], INPUT_LK],    // 2P E     as KEYPAD 5
    [[2, 'k1', 'key', 0x004d], INPUT_MK],    // 2P F     as KEYPAD 6
    // Player ONE
    [[1, 'k2', 'controller_button', GP2040_UP   ], INPUT_UP],    // 1P UP    as GP2040-CE UP
    [[1, 'k2', 'controller_button', GP2040_DOWN ], INPUT_DOWN],  // 1P DOWN  as GP2040-CE DOWN
    [[1, 'k2', 'controller_button', GP2040_LEFT ], INPUT_LEFT],  // 1P LEFT  as GP2040-CE LEFT
    [[1, 'k2', 'controller_button', GP2040_RIGHT], INPUT_RIGHT], // 1P RIGHT as GP2040-CE RIGHT
    [[1, 'k2', 'controller_button', GP2040_P1   ], INPUT_LP],    // 1P A     as GP2040-CE P1
    [[1, 'k2', 'controller_button', GP2040_K1   ], INPUT_MP],    // 1P B     as GP2040-CE K1
    [[1, 'k2', 'controller_button', GP2040_P2   ], INPUT_HP],    // 1P C     as GP2040-CE P2
    [[1, 'k2', 'controller_button', GP2040_K2   ], INPUT_AP],    // 1P D     as GP2040-CE K2
    [[1, 'k3', 'controller_button', GP2040_R1   ], INPUT_LK],    // 1P E     as GP2040-CE R1
    [[1, 'k3', 'controller_axis'  , GP2040_R2   ], INPUT_MK],    // 1P F     as GP2040-CE R2
    // Player TWO
    [[2, 'k2', 'controller_button', GP2040_R1   ], INPUT_UP],    // 2P UP    as GP2040-CE R1
    [[2, 'k2', 'controller_button', GP2040_L1   ], INPUT_DOWN],  // 2P DOWN  as GP2040-CE L1
    [[2, 'k2', 'controller_axis',   GP2040_R2   ], INPUT_LEFT],  // 2P LEFT  as GP2040-CE R2
    [[2, 'k2', 'controller_axis',   GP2040_S1   ], INPUT_RIGHT], // 2P RIGHT as GP2040-CE S1
    [[2, 'k2', 'controller_button', GP2040_S2   ], INPUT_LP],    // 2P A     as GP2040-CE S2
    [[2, 'k2', 'controller_button', GP2040_S1   ], INPUT_MP],    // 2P B     as GP2040-CE S1
    [[2, 'k2', 'controller_button', GP2040_L3   ], INPUT_HP],    // 2P C     as GP2040-CE L3
    [[2, 'k2', 'controller_button', GP2040_R3   ], INPUT_AP],    // 2P D     as GP2040-CE R3
    [[2, 'k2', 'controller_button', 0xFFFF      ], INPUT_LK],    // 2P E     as GP2040-CE
    [[2, 'k2', 'controller_button', 0xFFFF      ], INPUT_MK],    // 2P F     as GP2040-CE
    // Player ONE
    [[1, 'k3', 'controller_button', GP2040_UP   ], INPUT_UP],    // 1P UP    as GP2040-CE UP
    [[1, 'k3', 'controller_button', GP2040_DOWN ], INPUT_DOWN],  // 1P DOWN  as GP2040-CE DOWN
    [[1, 'k3', 'controller_button', GP2040_LEFT ], INPUT_LEFT],  // 1P LEFT  as GP2040-CE LEFT
    [[1, 'k3', 'controller_button', GP2040_RIGHT], INPUT_RIGHT], // 1P RIGHT as GP2040-CE RIGHT
    [[1, 'k3', 'controller_button', GP2040_P1   ], INPUT_LP],    // 1P A     as GP2040-CE P1
    [[1, 'k3', 'controller_button', GP2040_K1   ], INPUT_MP],    // 1P B     as GP2040-CE K1
    [[1, 'k3', 'controller_button', GP2040_P2   ], INPUT_HP],    // 1P C     as GP2040-CE P2
    [[1, 'k3', 'controller_button', GP2040_K2   ], INPUT_AP],    // 1P D     as GP2040-CE K2
    [[1, 'k3', 'controller_button', GP2040_R1   ], INPUT_LK],    // 1P E     as GP2040-CE R1
    [[1, 'k3', 'controller_axis',   GP2040_R2   ], INPUT_MK],    // 1P F     as GP2040-CE R2
    // Player TWO
    [[2, 'k3', 'controller_button', GP2040_UP   ], INPUT_UP],    // 1P UP    as GP2040-CE UP
    [[2, 'k3', 'controller_button', GP2040_DOWN ], INPUT_DOWN],  // 1P DOWN  as GP2040-CE DOWN
    [[2, 'k3', 'controller_button', GP2040_LEFT ], INPUT_LEFT],  // 1P LEFT  as GP2040-CE LEFT
    [[2, 'k3', 'controller_button', GP2040_RIGHT], INPUT_RIGHT], // 1P RIGHT as GP2040-CE RIGHT
    [[2, 'k3', 'controller_button', GP2040_P1   ], INPUT_LP],    // 1P A     as GP2040-CE P1
    [[2, 'k3', 'controller_button', GP2040_K1   ], INPUT_MP],    // 1P B     as GP2040-CE K1
    [[2, 'k3', 'controller_button', GP2040_P2   ], INPUT_HP],    // 1P C     as GP2040-CE P2
    [[2, 'k3', 'controller_button', GP2040_K2   ], INPUT_AP],    // 1P D     as GP2040-CE K2
    [[2, 'k3', 'controller_button', GP2040_R1   ], INPUT_LK],    // 1P E     as GP2040-CE R1
    [[2, 'k3', 'controller_axis',   GP2040_R2   ], INPUT_MK],    // 1P F     as GP2040-CE R2
  ]).forEach((v, k) => KEYBIS_MAP.set(k.join('-'), v));

  const KEYCODES = new Map([
    [INPUT_LP, ['VC_A', 'A']],
    [INPUT_MP, ['VC_B', 'B']],
    [INPUT_HP, ['VC_C', 'C']],
    [INPUT_AP, ['VC_D', 'D']],
    [INPUT_LK, ['VC_E', 'E']],
    [INPUT_MK, ['VC_F', 'F']],
  ]);

  // #region Keys with Icons

  /* Init SVG Icons */
  document
    .querySelectorAll('#icons-container svg')
    .forEach((i) => i.classList.add('icon-sm'));
  document
    .querySelectorAll('#icons-container svg path')
    .forEach((p) => p.setAttribute('fill', 'currentColor'));

  const ARROWICONS = new Map([
    [(INPUT_UP | INPUT_DOWN), null], //
    [(INPUT_LEFT | INPUT_RIGHT), null], //

    [(INPUT_UP | INPUT_LEFT), document.getElementById('SVG_VC_UP_LEFT').cloneNode(true).outerHTML.trim().replace(/\s+/g, ' ')], // ARROW UP + LEFT
    [(INPUT_UP | INPUT_RIGHT), document.getElementById('SVG_VC_UP_RIGHT').cloneNode(true).outerHTML.trim().replace(/\s+/g, ' ')], // ARROW UP + RIGHT

    [(INPUT_DOWN | INPUT_RIGHT), document.getElementById('SVG_VC_DOWN_RIGHT').cloneNode(true).outerHTML.trim().replace(/\s+/g, ' ')], // ARROW DOWN + RIGHT
    [(INPUT_DOWN | INPUT_LEFT), document.getElementById('SVG_VC_DOWN_LEFT').cloneNode(true).outerHTML.trim().replace(/\s+/g, ' ')], // ARROW DOWN + LEFT

    [INPUT_UP, document.getElementById('SVG_VC_UP').cloneNode(true).outerHTML.trim().replace(/\s+/g, ' ')], // ARROW UP
    [INPUT_LEFT, document.getElementById('SVG_VC_LEFT').cloneNode(true).outerHTML.trim().replace(/\s+/g, ' ')], // ARROW LEFT
    [INPUT_RIGHT, document.getElementById('SVG_VC_RIGHT').cloneNode(true).outerHTML.trim().replace(/\s+/g, ' ')], // ARROW RIGHT
    [INPUT_DOWN, document.getElementById('SVG_VC_DOWN').cloneNode(true).outerHTML.trim().replace(/\s+/g, ' ')], // ARROW DOWN
  ]);
  const ARROW_POSITIONS = new Map([
    [0, [0, 0]], //

    [(INPUT_UP | INPUT_LEFT), [-63, -63]], // ARROW UP + LEFT
    [(INPUT_UP | INPUT_RIGHT), [-63, 63]], // ARROW UP + RIGHT

    [(INPUT_DOWN | INPUT_RIGHT), [63, 63]], // ARROW DOWN + RIGHT
    [(INPUT_DOWN | INPUT_LEFT), [63, -63]], // ARROW DOWN + LEFT

    [INPUT_UP, [-70, 0]], // ARROW UP
    [INPUT_LEFT, [0, -70]], // ARROW LEFT
    [INPUT_RIGHT, [0, 70]], // ARROW RIGHT
    [INPUT_DOWN, [70, 0]], // ARROW DOWN
  ]);
  ARROW_POSITIONS.forEach((v) => {
    v[0] += 25;
    v[1] += 25;
  })

  const KEY_CLASS_MAP = new Map([
    ['N', ['key']],
    ['A', ['key', 'lp']],
    ['B', ['key', 'mp']],
    ['C', ['key', 'hp']],
    ['D', ['key', 'ap']],
    ['E', ['key', 'lk']],
    ['F', ['key', 'mk']],
  ]);
  ARROWICONS.forEach((html, keybit) => { if (html) { KEY_CLASS_MAP.set(html, ['key', 'bl']) } });

  // #endregion

  const _mainHolderDiv = document.querySelector('.mainHolder');
  const _p1Holder = _mainHolderDiv.cloneNode(true);
  _p1Holder.classList.add('player1');
  _mainHolderDiv.classList.add('player2');
  const _playersHolderDiv = document.querySelector('.playersHolder');
  _playersHolderDiv.append(_p1Holder);
  const _debugBoxDiv = document.querySelector('.debugBox');
  const _debugTextDiv = document.querySelector('.debugText');

  const xhr = new XMLHttpRequest();
  xhr.overrideMimeType('application/json');

  function pollJSON() {
    xhr.open('GET', './streamcontrol.json?t=' + Date.now(), true);
    xhr.onerror = (e) => console.log(e);
    try {
      xhr.send();
    } catch (e) {
      console.log(e);
    }
  }

  function toBoolean(v, ifNull) {
    return 1 === parseInt(v || ifNull);
  }

  function parseJSON() {
    if (xhr.readyState === 4) {
      let config = JSON.parse(xhr.responseText);
      HISTORY_MAX = parseInt(config['historyMax'] || 22);
      HISTORY_TIMEOUT = parseInt(config['historyTimeout'] || 30000);
      HISTORY_TOP_ALIGN = toBoolean(config['historyTopAlign'], true);
      HIST_HTML = toBoolean(config['hist'], true);
      INPUT_HTML = toBoolean(config['input'], true);
      DEBUG = toBoolean(config['debug'], true);
      OPACITY = (parseInt(config['opacity'] || 100) / 100.0);
      const prevPORT = PORT;
      PORT = (parseInt(config['port'] || 16899) | 0);
      if (prevPORT !== PORT) {
        startWebsocket();
      }
      _p1History.applyConfig(config);
      _p2History.applyConfig(config);
    }
    if (DEBUG) {
      _debugBoxDiv.classList.remove('hidden');
    } else {
      _debugBoxDiv.classList.add('hidden');
    }
    if (OPACITY) {
      _playersHolderDiv.style.opacity = OPACITY;
    }
  }

  xhr.onreadystatechange = parseJSON;

  /**
   * This will either return an HTML string (icon)
   * Or a plain string (libuiohook key name)
   *
   * @param {string} keybit
   * @returns {string} Inline innerHTML equivalent of key
   */
  function getKeyHTML(keybit) {
    return Array.from(KEYCODES).filter(([bit, key]) => (keybit & bit) === bit).map(([bit, key]) => key[1] !== '' ? key[1] : key[0]);
  }

  // #region DOM Utils

  /**
   * Wraps an HTML string of a key with span
   *
   * @returns {ParentNode} HTML Element created with classes
   */
  function createElement(element, html = '', classList = []) {
    const el = document.createElement(element);
    el.classList.add(...classList);
    el.innerHTML = html;
    return el;
  }

  /**
   * @returns {ParentNode}
   */
  function doAppend(element1, element2) {
    element1.appendChild(element2);
    return element1;
  }

  // #endregion

  // Vertical align setup
  if (!HISTORY_TOP_ALIGN) {
    const histHolder = document.querySelector('.histHolder');
    histHolder.classList.add('bottom-align');
  }

  const CANVAS_FIX = 285;
  function toCanvasPoint(x, y) {
    return [(x * 3.8) + CANVAS_FIX, (y * 3.8) + CANVAS_FIX];
  }

  // https://stackoverflow.com/questions/4810841/pretty-print-json-using-javascript
  function syntaxHighlight(json) {
    if (typeof json != 'string') {
      json = JSON.stringify(json, undefined, 2);
    }
    json = json.replace(/&/g, '&amp;').replace(/</g, '&lt;').replace(/>/g, '&gt;');
    json = json.replace(/("(\\u[a-zA-Z0-9]{4}|\\[^u]|[^\\"])*"(\s*:)?|\b(true|false|null)\b|-?\d+(?:\.\d*)?(?:[eE][+\-]?\d+)?)/g, function (match) {
      var cls = 'jsonNumber';
      if (/^"/.test(match)) {
        if (/:$/.test(match)) {
          cls = 'jsonKey';
        } else {
          cls = 'jsonString';
        }
      } else if (/true|false/.test(match)) {
        cls = 'jsonBoolean';
      } else if (/null/.test(match)) {
        cls = 'jsonNull';
      }
      return `<span class='${cls}'>${match}</span>`;
    });
    return `<pre>${json}</pre>`
  }

  class ClsHistory {
    constructor(player) {
      this._player = player;
      this._playerDiv = document.querySelector('.player' + player);
      this._historyDiv = this._playerDiv.querySelector('.history');
      this._ballDiv = this._playerDiv.querySelector('.ballTop-body');
      this._balltopDiv = this._playerDiv.querySelector('.stick .ballTop');
      this._lpDiv = this._playerDiv.querySelector('.lp .btn-wrap .btn-body');
      this._mpDiv = this._playerDiv.querySelector('.mp .btn-wrap .btn-body');
      this._hpDiv = this._playerDiv.querySelector('.hp .btn-wrap .btn-body');
      this._apDiv = this._playerDiv.querySelector('.ap .btn-wrap .btn-body');
      this._lkDiv = this._playerDiv.querySelector('.lk .btn-wrap .btn-body');
      this._mkDiv = this._playerDiv.querySelector('.mk .btn-wrap .btn-body');
      this._counterDiv = undefined;
      this._histDiv = this._playerDiv.querySelector('.histHolder');
      this._centerDiv = this._playerDiv.querySelector('.centerHolder');
      this._historyCurrentlyPressed = new Set();
      this.DELAY_FRAMES = 10;
      this._combinedKeybitQueue = Array(this.DELAY_FRAMES).fill().map((x) => INPUT_NAN);
      this._prev_arrows = -1;
      this._hideLastTimeoutID = undefined;
      this._repeatCount = 0;
      this._repeatTimeoutID = undefined;
      this._mouseButtonsMask = 0;
      // Buffer filling
      for (let step = 0; step < HISTORY_MAX; step++) {
        const pElement = createElement('p', '', ['key-combination', 'hidden']);
        doAppend(this._historyDiv, pElement);
      }
      this._inputType = 'k1';
      this._stickLines = Array(40).fill().map((x) => toCanvasPoint(25, 25));
      this._stickLineColor = Array(40).fill().map((x, idx) =>
        'rgb(210, ' + Math.floor(135 - idx * 2) + ', ' + Math.floor(235 - idx * 2) + ')'
      );
      this._canvas = this._playerDiv.querySelector('.canvas');
      this._ctx = this._canvas.getContext('2d');
      this._ctx.lineCap = 'round';
      this._ctx.imageSmoothingQuality = 'high';
      this._ctx.imageSmoothingEnabled = true;
      this._ctx.mozImageSmoothingEnabled = true;
      this._ctx.msImageSmoothingEnabled = true;
      this._ctx.webkitImageSmoothingEnabled = true;
      this._ctx.shadowOffsetX = 0;
      this._ctx.shadowOffsetY = 0;
      this._ctx.shadowBlur = 20;
      this._ctx.lineWidth = 75;
      this._ctx.fillStyle = 'rgb( 0, 0, 0)';
      this._ctx.fillRect(0, 0, this._canvas.width, this._canvas.height);
    }

    buttonLayout(typeval = 'line') {
      this.buttonLayoutClass = typeval;
      const el = this._playerDiv.querySelector('.stickart');
      if (el.classList.contains(typeval)) return;
      el.classList.remove('line', 'box', 'samurai', 'six');
      el.classList.add(typeval);
    }

    applyConfig(config) {
      this.buttonLayout(config['buttonLayout'] || 'line'); // 'line' 'box' 'samurai' 'six'
      this._inputType = (config[`inputType`] || 'k1'); // 'k1' 'k2' 'k3'
      this._inputDevice = parseInt(config[`inputDevice${this._player}p`] || 0);
      this.DELAY_FRAMES = Math.max(1, parseInt(config['delayFrames'] || 2));
      if (this._combinedKeybitQueue.length !== this.DELAY_FRAMES) {
        this._combinedKeybitQueue = Array(this.DELAY_FRAMES).fill().map((x) => INPUT_NAN);
      }
      if (!HIST_HTML) {
        this._histDiv.classList.add('hide');
      } else {
        this._histDiv.classList.remove('hide');
      }
      if (!INPUT_HTML) {
        this._centerDiv.classList.add('hide');
      } else {
        this._centerDiv.classList.remove('hide');
      }
    }

    calcKeyCombinatedKeybit(historyCurrentlyPressed) {
      let combinedKeybit = Array.from(historyCurrentlyPressed)
        .reduce((arrows, keybit) => (arrows |= keybit), 0);
      if ((combinedKeybit & INPUT_LEFT_AND_RIGHT) == INPUT_LEFT_AND_RIGHT) {
        combinedKeybit -= INPUT_LEFT_AND_RIGHT;
      }
      if ((combinedKeybit & INPUT_UP_AND_DOWN) == INPUT_UP_AND_DOWN) {
        combinedKeybit -= INPUT_UP_AND_DOWN;
      }
      return combinedKeybit;
    }

    createCombinedKeybit(keybit, isPressing) {
      let combinedKeybit;
      if (isPressing) {
        // Register new pressed key
        this._historyCurrentlyPressed.add(keybit);

        combinedKeybit = this.calcKeyCombinatedKeybit(this._historyCurrentlyPressed);
      }
      // If releasing a key
      else {
        // Update current keys state
        this._historyCurrentlyPressed.delete(keybit);

        combinedKeybit = this.calcKeyCombinatedKeybit(this._historyCurrentlyPressed);

        // Fade element out if no more held keys left
        if (this._historyCurrentlyPressed.size == 0) {
          this.startRemovingLast();
        }
      }

      if (this.buttonLayoutClass !== 'six') {
        combinedKeybit &= 0xFF0F;
      }

      return combinedKeybit;
    }

    updateKey(keycode, type, isPressing, data) {
      if (this._inputType === 'k3') {
        if (data.device_index !== this._inputDevice) {
          return;
        }
      }

      const keybit = KEYBIS_MAP.get([this._player, this._inputType, type.replace(/_(down|up|pressed|released|motion)$/g, ''), keycode].join('-'));

      //console.log(keybit, keycode, isPressing, data);

      // Keyboard event
      if (!!keybit) {
        // Prevents white space from unassigned keycodes
        const combinedKeybit = this.createCombinedKeybit(keybit, isPressing);
        this._combinedKeybitQueue[this.DELAY_FRAMES - 1] = combinedKeybit;
      }
    }

    updateUI1(frames, combinedKeybit) {
      const samekey = this._prev_arrows === combinedKeybit;
      if (samekey) {
        this._repeatCount += frames;
      } else {
        if (this._counterDiv) {
          this._counterDiv.classList.remove('repeat-counter');
        }

        const combinationElement = createElement('p', '', ['key-combination']);
        try {
          // Build HTML for the key combination
          const keyHTML = [createElement('span', this._repeatCount, ['repeat', 'repeat-counter'])]
            .concat(
              [ARROWICONS.get(combinedKeybit & INPUT_MASK_ARROW) || 'N']
                .concat(getKeyHTML(combinedKeybit & INPUT_MASK_BUTTON).sort())
                .map((html) => createElement('span', html, KEY_CLASS_MAP.get(html)))
            );
          keyHTML.reduce(doAppend, combinationElement);
        } catch (e) {
          console.error(e);
        }

        // Fade out elements that were kept because a key was still pressed
        this.startRemovingLast();

        if (HIST_HTML) {
          if (HISTORY_TOP_ALIGN) {
            this._historyDiv.insertBefore(combinationElement, this._historyDiv.firstChild);
          } else {
            this._historyDiv.appendChild(combinationElement);
            window.scrollTo({ top: document.body.scrollHeight });
          }

          // Remove oldest element
          while (this._historyDiv.children.length > HISTORY_MAX) {
            if (HISTORY_TOP_ALIGN) {
              this._historyDiv.lastElementChild.remove();
            } else {
              this._historyDiv.firstElementChild.remove();
            }
          }
        }

        this._prev_arrows = combinedKeybit;
        this._repeatCount = frames;
        this._counterDiv = this._playerDiv.querySelector('.repeat-counter');
      }

      if (this._counterDiv && (this._repeatCount <= 999)) {
        this._counterDiv.innerHTML = this._repeatCount | 0;
      }
    }

    updateUI2(combinedKeybit) {
      // A as Jab
      if ((combinedKeybit & INPUT_LP) === INPUT_LP) {
        this._lpDiv.classList.remove('inactive');
      } else {
        this._lpDiv.classList.add('inactive');
      }
      // B as Strong
      if ((combinedKeybit & INPUT_MP) === INPUT_MP) {
        this._mpDiv.classList.remove('inactive');
      } else {
        this._mpDiv.classList.add('inactive');
      }
      // C as Fierce
      if ((combinedKeybit & INPUT_HP) === INPUT_HP) {
        this._hpDiv.classList.remove('inactive');
      } else {
        this._hpDiv.classList.add('inactive');
      }
      // D as All Punches
      if ((combinedKeybit & INPUT_AP) === INPUT_AP) {
        this._apDiv.classList.remove('inactive');
      } else {
        this._apDiv.classList.add('inactive');
      }
      // E
      if ((combinedKeybit & INPUT_LK) === INPUT_LK) {
        this._lkDiv.classList.remove('inactive');
      } else {
        this._lkDiv.classList.add('inactive');
      }
      // F
      if ((combinedKeybit & INPUT_MK) === INPUT_MK) {
        this._mkDiv.classList.remove('inactive');
      } else {
        this._mkDiv.classList.add('inactive');
      }
      let [y, x] = ARROW_POSITIONS.get(combinedKeybit & INPUT_MASK_ARROW) || [25, 25];
      if (y === 25 && x === 25) {
        this._ballDiv.classList.add('inactive');
      } else {
        this._ballDiv.classList.remove('inactive');
      }
      this._balltopDiv.style.left = `${x}px`;
      this._balltopDiv.style.top = `${y}px`;
      this._stickLines.push(toCanvasPoint(x, y));
      this._stickLines.shift();

      if (this._canvas.getContext) {
        this._ctx.clearRect(0, 0, this._canvas.width, this._canvas.height);
        this._stickLines.forEach(([x, y], idx) => {
          if (idx == 0) {
            this._ctx.beginPath();
            this._ctx.moveTo(x, y);
          } else {
            this._ctx.lineTo(x, y);
            this._ctx.strokeStyle = this._stickLineColor[idx];
            this._ctx.shadowColor = this._stickLineColor[idx];
            this._ctx.stroke();
            if ((idx + 1) < this._stickLines.length) {
              this._ctx.beginPath();
              this._ctx.moveTo(x, y);
            }
          }
        });
      }
    }

    updateUI(frames) {
      this._combinedKeybitQueue.push(this._combinedKeybitQueue[this.DELAY_FRAMES - 1]);
      let combinedKeybit = this._combinedKeybitQueue.shift();
      this.updateUI1(frames, combinedKeybit);
      this.updateUI2(combinedKeybit);
    }

    startRemovingLast() {
      if (HISTORY_TIMEOUT_ACTIVE) {
        if (this._hideLastTimeoutID) clearTimeout(this._hideLastTimeoutID);
        this._hideLastTimeoutID = setTimeout(() => {
          Array.from(this._historyDiv.children).forEach((e) => {
            e.classList.add('hidden');
          });
        }, HISTORY_TIMEOUT);
      }
    }
  }

  const _p1History = new ClsHistory(1);
  const _p2History = new ClsHistory(2);

  function onKeyEvent(data, e) {
    if (data.event_type) {
      if (data.event_type.startsWith('mouse')) return;

      if (data.event_type === 'key_typed') return;

      let isPressing = false;
      isPressing |= (data.event_type === 'key_pressed');
      isPressing |= (data.event_type === 'controller_button_down');
      isPressing |= (data.event_type === 'controller_axis_motion' && data.virtual_value === 1);

      let keycode = data.keycode || data.virtual_code;

      if (DEBUG) {
        _debugTextDiv.innerHTML = syntaxHighlight(data);
      }

      _p1History.updateKey(keycode, data.event_type, isPressing, data);
      _p2History.updateKey(keycode, data.event_type, isPressing, data);
    } else {
      console.log(data);
    }
  }

  function onData(e) {
    const data = JSON.parse(e.data);
    onKeyEvent(data, e);
  }

  // Make the function wait until the connection is made...
  function waitForSocketConnection(socket, callback) {
    setTimeout(function () {
      if (socket.readyState === 1) {
        console.log('Connection is made');
        if (callback != null) {
          callback(socket);
        }
      } else {
        console.log('wait for connection...');
        waitForSocketConnection(socket, callback);
      }
    }, 5); // wait 5 milisecond for the connection...
  }

  const b64toBlob = (b64Data, contentType = '', sliceSize = 512) => {
    const byteCharacters = atob(b64Data);
    const byteArrays = [];

    for (let offset = 0; offset < byteCharacters.length; offset += sliceSize) {
      const slice = byteCharacters.slice(offset, offset + sliceSize);

      const byteNumbers = new Array(slice.length);
      for (let i = 0; i < slice.length; i++) {
        byteNumbers[i] = slice.charCodeAt(i);
      }

      const byteArray = new Uint8Array(byteNumbers);
      byteArrays.push(byteArray);
    }

    const blob = new Blob(byteArrays, { type: contentType, endings: 'native' });
    return blob;
  }

  function startWebsocket() {
    if (_ws) {
      _ws.close();
    }

    _ws = new WebSocket(`ws://localhost:${PORT}/`);

    _ws.onmessage = onData;

    _ws.onerror = (e) => {
      console.log('WebSocket error: ');
      console.error(e);
    };

    _ws.onclose = () => {
      // connection closed, discard old websocket and create a new one in 2s
      _ws = null;
      setTimeout(startWebsocket, 2000);
    };
  }

  const LOOP_START_TIME = performance.now();
  let totalFrames = 0.0;
  let totalFramesInt = 0;

  function frameLoop(onFrameUpdate) {
    let handler = {};
    let loop = function (time) {
      let period = time - LOOP_START_TIME;
      if (16.5 < period) {
        let newTotalFrames = (time - LOOP_START_TIME) / FRAME_PERIOD;
        let newTotalFramesInt = newTotalFrames | 0;
        onFrameUpdate(newTotalFramesInt - totalFramesInt);
        totalFrames = newTotalFrames;
        totalFramesInt = newTotalFramesInt;
      }
      handler.id = requestAnimationFrame(loop);
    };
    handler.id = requestAnimationFrame(loop);
    return handler;
  }

  pollJSON();
  setInterval(pollJSON, 800);

  let frameHandler = frameLoop((frames) => {
    _p1History.updateUI(frames);
    _p2History.updateUI(frames);
  });

  startWebsocket();
</script>

</html>